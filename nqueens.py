# -*- coding: utf-8 -*-
"""
Complete this code for combinatorial optimization  problem

Please remove author name if generated by machine automatically
Keep you code anonymous

"""

# Use standard python package only.
import random 
import math
import numpy as np
import matplotlib as plt

POPULATION_SIZE = 100 # Change POPULATION_SIZE to obtain better fitness.

GENERATIONS = 100 # Change GENERATIONS to obtain better fitness.
SOLUTION_FOUND = False

CORSSOVER_RATE = 0.7 # Change CORSSOVER_RATE  to obtain better fitness.
MUTATION_RATE = 0.3 # Change MUTATION_RATE to obtain better fitness.
ELITISM = False

'''CHANGE THIS to change board size and number of queens'''
BOARD_SIZE = 6
QUEENS = BOARD_SIZE


"""
    POPULATION GENERATIONS
"""
def generate_population(size):
    
    population = []
    
    for i in range(size):
        individual = [random_gene() for i in range(BOARD_SIZE)]
        
        population.append(individual)
    
    return population

def random_gene():
    row = ['0' for x in range(0,BOARD_SIZE)]
    draw = random.randint(0, BOARD_SIZE-1)
    row[draw] = '1'

    return row

def next_generation(previous_population):

    next_generation = []

    if ELITISM == True:
        elite = sorted(previous_population, key = compute_fitness)
        
        elite_size = int(len(elite) * 0.1)
        next_generation = []
        next_generation.extend(elite[:10])

        for i in range(POPULATION_SIZE - elite_size):
            first_parent = selection(previous_population)
            second_parent = selection(previous_population)
        
            if i < ((POPULATION_SIZE-elite_size) * CORSSOVER_RATE):
                offspring = crossover(first_parent, second_parent)
            else:
                offspring = mutation(random.choice(previous_population))

            next_generation.append(offspring)

    if ELITISM == False:
        for i in range(POPULATION_SIZE):
            first_parent = selection(previous_population)
            second_parent = selection(previous_population)

            if i < (int((POPULATION_SIZE) * CORSSOVER_RATE)):
                offspring = crossover(first_parent, second_parent)
            else:
                offspring = mutation(random.choice(previous_population))

            next_generation.append(offspring)

    return next_generation   

"""
    FITNESS COMPUTATIONS
"""
def compute_fitness(individual):

   

    fitness = 0    

    for i in range(len(individual)):

        for j in range(len(individual[i])):

            if individual[i][j] == '1':
                
                if not check_diagonals(individual, i, j) and not check_straight(individual, j):
                    fitness += 1
    return fitness



def check_diagonals(individual, i, j):
    tempi, tempj = i, j

    ''' SEARCH ALL VALUES UP AND TO THE LEFT '''
    while tempi > 0 and tempj > 0:
        tempi -= 1
        tempj -= 1

        if individual[tempi][tempj] == '1':
            return True

    tempi, tempj = i, j



    ''' SEARCH ALL VALUES DOWN AND TO RIGHT '''
    while tempi < len(individual) - 1 and tempj < len(individual) - 1:
        tempi += 1
        tempj += 1

        if individual[tempi][tempj] == '1':
            return True

    tempi, tempj = i, j

    
    ''' SEARCH ALL VALUES UP AND TO RIGHT '''
    while tempi > 0 and tempj > len(individual)-1:
        tempi -= 1
        tempj += 1

        if individual[tempi][tempj] == '1':
            return True

    tempi, tempj = i, j


    ''' SEARCH ALL VALUES DOWN AND TO LEFT '''
    while tempi < len(individual) - 1 and tempj > 0:
        tempi += 1
        tempj -= 1

        if individual[tempi][tempj] == '1':
            return True

    return False

def check_straight(individual, j):

    ''' Loop to N times '''
    count = 0

    for row in individual:
        if row[j] == '1':
            count += 1
    

    if count > 1:
        return True
    else:
        return False
"""
    SORTING & PRINTING
"""
def sort_population(population):
    return sorted(population, key=compute_fitness, reverse = False) #lowest first
    
def printpop(population):
    return [print(f"{individual} -- {compute_fitness(individual)}") for  individual in population]


"""
    SELECTION METHODS
"""
def selection(population):

    first_pick = random.choice(population)
    second_pick = random.choice(population)

    first_pick_fitness = compute_fitness(first_pick)
    second_pick_fitness = compute_fitness(second_pick)

    '''The Battle'''
    if first_pick_fitness > second_pick_fitness:
        return first_pick
    else:
        return second_pick
    '''The Battle'''
    

"""
    OPERANDS
"""
def crossover(first_parent, second_parent):
    
    individual = [] # Update this line if you need to

    crossover_point = random.randint(1, BOARD_SIZE-1)
    offspring = first_parent[:crossover_point] + second_parent[crossover_point:]
    return offspring

def mutation(individual):
    
    draw_row = random.randint(0,BOARD_SIZE-1)
    draw_column = random.randint(0,BOARD_SIZE-1)

    if individual[draw_row][draw_column] == '0':
        
        existing_one = individual[draw_row].index('1')
        individual[draw_row][existing_one] = '0'

        individual[draw_row][draw_column] ='1'
        
    
    elif individual[draw_row][draw_column] == '1':
        individual[draw_row][draw_column] = '0'

        draw_new_column = random.randint(0,BOARD_SIZE-1)
        individual[draw_row][draw_new_column] = '1'

    return individual    

def main(): 
    global POPULATION_SIZE 
    global GENERATIONS
    global SOLUTION_FOUND
    

    generation = 0

    population = generate_population(POPULATION_SIZE)
    
    while (True):
        
        population_sorted = sorted(population, key = compute_fitness)
        if compute_fitness(population_sorted[-1]) == QUEENS:
            print(f"Solution Found: {population_sorted[0]}")
            break

        print(f"Gen({generation}): {population_sorted[-1]} - Fitness: {compute_fitness(population_sorted[-1])}")

        population = next_generation(population)
        generation += 1

        if(generation > math.inf):
            break 

if __name__ == '__main__': 
    main()
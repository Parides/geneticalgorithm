# -*- coding: utf-8 -*-
"""
Complete this code for combinatorial optimization  problem

Please remove author name if generated by machine automatically
Keep you code anonymous

"""

# Use standard python package only.
import random 
import math
import numpy as np
import matplotlib as plt


# MINIMUM GLOBAL VARIABLES TO BE USED
POPULATION_SIZE = 100 # Change POPULATION_SIZE to obtain better fitness.

GENERATIONS = 100 # Change GENERATIONS to obtain better fitness.
SOLUTION_FOUND = False

CORSSOVER_RATE = 0.7 # Change CORSSOVER_RATE  to obtain better fitness.
MUTATION_RATE = 0.3 # Change MUTATION_RATE to obtain better fitness.
ELITISM = True


'''Change KNAPSACK_THRESHOLD to change the carry weight of the bag'''
KNAPSACK_THRESHOLD = 13

'''You can change this to your liking'''
ITEMS_GENERATE = KNAPSACK_THRESHOLD
ITEMS = []

CHOICES = '''01'''

for x in range (0,ITEMS_GENERATE):
    item = {
        "i" : x+1,
        "w" : random.randint(1,5),
        "v" : random.randint(0,10)
    }
    ITEMS.append(item)

# SOLUTION = ["0" for x in range(50)]

"""
    POPULATION GENERATIONS
"""
def generate_population(size):

    population = []  
    for i in range (POPULATION_SIZE):

        knapsack = [random.choice(CHOICES) for x in range(0,ITEMS_GENERATE)]
        population.append(knapsack)


    return population


def next_generation(previous_population):

    next_generation = []

    if ELITISM == True:
        elite = sorted(previous_population, key = compute_fitness)

        elite_size = int(len(elite) * 0.1)
        next_generation = []
        next_generation.extend(elite[:10])

        for i in range(POPULATION_SIZE - elite_size):
            first_parent = selection(previous_population)
            second_parent = selection(previous_population)
        
            if i < ((POPULATION_SIZE-elite_size) * CORSSOVER_RATE):
                offspring = crossover(first_parent, second_parent)
            else:
                offspring = mutation(random.choice(previous_population))

            next_generation.append(offspring)

    if ELITISM == False:
        for i in range(POPULATION_SIZE):
            first_parent = selection(previous_population)
            second_parent = selection(previous_population)

            if i < (int((POPULATION_SIZE) * CORSSOVER_RATE)):
                offspring = crossover(first_parent, second_parent)
            else:
                offspring = mutation(random.choice(previous_population))

            next_generation.append(offspring)

    return next_generation   

"""
    FITNESS COMPUTATIONS
"""
def compute_fitness(knapsack):

    knapsack_value = 0
    knapsack_weight = 0

    for item_chosen, actual_item in zip(knapsack,ITEMS):
        if item_chosen == '1':
            knapsack_value += actual_item['v']
            knapsack_weight += actual_item['w'] 


    if knapsack_weight > KNAPSACK_THRESHOLD:
        return 0
    else:
        return knapsack_value

"""
    SORTING & PRINTING
"""
def sort_population(population):
    return sorted(population, key=compute_fitness, reverse = False) #lowest last
    
def printpop(population):
    return [print(f"{individual} -- {compute_fitness(individual)}") for  individual in population]


"""
    SELECTION METHODS
"""
def selection(population):

    first_pick = random.choice(population)
    second_pick = random.choice(population)

    first_pick_fitness = compute_fitness(first_pick)
    second_pick_fitness = compute_fitness(second_pick)

    '''The Battle'''
    if first_pick_fitness > second_pick_fitness:
        # return first_pick
        return first_pick
    else:
        # return second_pick
        return second_pick
    '''The Battle'''
    

"""
    OPERANDS
"""
def crossover(first_parent, second_parent):
    
    # individual = [] # Update this line if you need to

    # # for first_parent_character, second_parent_character in zip(first_parent, second_parent):
        
    # #     if (first_parent_character == '0') and (second_parent_character == '0'):
    # #         individual.append('0')

    # #     elif (first_parent_character == '1') and (second_parent_character == '1'):
    # #         individual.append('1')
        
    # #     elif first_parent_character != second_parent_character:
    # #         individual.append('0') # for minimizations
    # #         # individual.append('1') #for maximization


    # i = random.randint(0,1)
    # for first_parent_character, second_parent_character in zip(first_parent, second_parent):
        
    #     if i % 2 == 0:
    #         individual.append(first_parent_character)
    #     else:
    #         individual.append(second_parent_character)
        
    #     i += 1
    # return [random.choice(CHOICES) for x in range(0,ITEMS_GENERATE)]

   
    crossover_point = random.randint(1, KNAPSACK_THRESHOLD-1)
    offspring = first_parent[:crossover_point] + second_parent[crossover_point:]


    return offspring

def mutation(individual):
    
    individual_size = len(individual)

    draw = random.randint(0,individual_size-1)

    individual_characters = list(individual)
    # individual_characters[draw] = random_gene()
    if individual_characters[draw] == '0':
        individual_characters[draw] ='1'
    
    if individual_characters[draw] == '1':
        individual_characters[draw] = '0'

    return individual_characters    

def main(): 
    global POPULATION_SIZE 
    global GENERATIONS
    global SOLUTION_FOUND
    

    generation = 0

    population = generate_population(POPULATION_SIZE)
    goat = [random.choice(CHOICES) for x in range(0,ITEMS_GENERATE)]
    
    while (True):  # TODO: write your termination condition here or within the loop 
        #TODO: write your generation propagation code here 

        
        population_sorted = sorted(population, key = compute_fitness, reverse=True)
        if compute_fitness(population_sorted[0]) > compute_fitness(goat):
            goat = population_sorted[0]

        print(f"Gen({generation}): {population_sorted[0]} : {compute_fitness(population_sorted[0])}")

        population = next_generation(population)
        generation += 1

        if(generation > GENERATIONS):
            break
    print("=====================================================")
    print(f"After {GENERATIONS} generations were completed:")
    print(f"Fittest Ever: {goat} - fitness: {compute_fitness(goat)}")
    print(f"Knapsack Threshold: {KNAPSACK_THRESHOLD}")
    print(f"Items: {ITEMS}")
if __name__ == '__main__': 
    main()
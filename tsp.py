# -*- coding: utf-8 -*-
"""
Complete this code for combinatorial optimization  problem

Please remove author name if generated by machine automatically
Keep you code anonymous

"""

# Use standard python package only.
import random 
import math
import numpy as np
import matplotlib as plt


# MINIMUM GLOBAL VARIABLES TO BE USED
POPULATION_SIZE = 100 # Change POPULATION_SIZE to obtain better fitness.

GENERATIONS = 100 # Change GENERATIONS to obtain better fitness.
SOLUTION_FOUND = False

CORSSOVER_RATE = 0.7 # Change CORSSOVER_RATE  to obtain better fitness.
MUTATION_RATE = 0.3 # Change MUTATION_RATE to obtain better fitness.
ELITISM = True

'''CHANGE NUMBER OF CITIES. CITY DISTANCES AND STARTING CITY ARE GENERATED RANDOMLY'''
CITIES = 10
CHOICES = [n for n in range (0,CITIES)]
STARTING_CITY = random.choice(CHOICES)
CHOICES.remove(STARTING_CITY)

def random_row():
    row = [random.sample(CHOICES,len(CHOICES))]
    row[0].insert(0,STARTING_CITY)
    row[0].append(STARTING_CITY)
    return row
    
DISTANCE_MAP = [[random.randint(1,100) for x in range(CITIES)] for x in range(CITIES)]
i,j = 0,0
while i< (CITIES) and j < (CITIES):
    DISTANCE_MAP[i][j] = 0
    i += 1
    j += 1

"""
    POPULATION GENERATIONS
"""
def generate_population(size):

    population = []  
    for i in range (POPULATION_SIZE):
        
        path = random_row()[0]
        population.append(path)


    return population


def next_generation(previous_population):

    next_generation = []

    if ELITISM == True:
        elite = sorted(previous_population, key = compute_fitness)

        elite_size = int(len(elite) * 0.1)
        next_generation = []
        next_generation.extend(elite[:10])

        for i in range(POPULATION_SIZE - elite_size):
            first_parent = selection(previous_population)
            second_parent = selection(previous_population)
        
            if i < ((POPULATION_SIZE-elite_size) * CORSSOVER_RATE):
                offspring = random_row()[0]
            else:
                offspring = random_row()[0]

            next_generation.append(offspring)

    if ELITISM == False:
        for i in range(POPULATION_SIZE):
            first_parent = selection(previous_population)
            second_parent = selection(previous_population)

            if i < (int((POPULATION_SIZE) * CORSSOVER_RATE)):
                offspring = random_row()[0]
            else:
                offspring = random_row()[0]

            next_generation.append(offspring)

    return next_generation   

"""
    FITNESS COMPUTATIONS
"""
def compute_fitness(path):

    fitness = 0
    for x in range(0,len(path)-1):
        fitness += DISTANCE_MAP[path[x]][path[x+1]]

    return fitness

"""
    SORTING & PRINTING
"""
def sort_population(population):
    return sorted(population, key=compute_fitness, reverse = False) #lowest last
    
def printpop(population):
    return [print(f"{individual} -- {compute_fitness(individual)}") for  individual in population]


"""
    SELECTION METHODS
"""
def selection(population):

    first_pick = random.choice(population)
    second_pick = random.choice(population)

    first_pick_fitness = compute_fitness(first_pick)
    second_pick_fitness = compute_fitness(second_pick)

    '''The Battle'''
    if first_pick_fitness > second_pick_fitness:
        # return first_pick
        return second_pick
    else:
        # return second_pick
        return first_pick
    '''The Battle'''
    

"""
    OPERANDS
"""
def crossover(first_parent, second_parent):
   
    crossover_point = random.randint(1, 1)
    offspring = first_parent[:crossover_point] + second_parent[crossover_point:]

    return offspring

def mutation(individual):
    
    individual_size = len(individual)

    draw = random.randint(0,individual_size-1)

    individual_characters = list(individual)
    # individual_characters[draw] = random_gene()
    if individual_characters[draw] == '0':
        individual_characters[draw] ='1'
    
    if individual_characters[draw] == '1':
        individual_characters[draw] = '0'

    return individual_characters    

def main(): 
    global POPULATION_SIZE 
    global GENERATIONS
    global SOLUTION_FOUND
    

    generation = 0

    population = generate_population(POPULATION_SIZE)
    goat = [random.choice(population)][0]
    
    while (True):

        
        population_sorted = sorted(population, key = compute_fitness, reverse=False)
        if compute_fitness(population_sorted[0]) < compute_fitness(goat):
            goat = population_sorted[0]

        print(f"Gen({generation}): {population_sorted[0]} - Fitness: {compute_fitness(population_sorted[0])}")

        population = next_generation(population)
        generation += 1

        if(generation > GENERATIONS):
            break
    
    print(f"Fittest Ever: {goat} - Fitness: {compute_fitness(goat)}")

if __name__ == '__main__': 
    main()